import random
from typing import Optional

import numpy as np
import pandas as pd

from bingo import APP_NAME
from bingo.custom_logger import getLogger

lg = getLogger(APP_NAME)


class BingoBoard:
    """
    Represents a single Bingo board with a square matrix of numbers.
    """

    size: int
    matrix: dict[str, dict[str, int]]
    number_pool: list[int]

    is_winner: bool = False
    is_validated: bool = False

    df: Optional[pd.DataFrame] = None
    json_str: Optional[str] = None
    df_marked: Optional[pd.DataFrame] = None
    json_str_marked: Optional[str] = None

    def __init__(self, size=7, number_pool_size: int = 200):
        """Initializes a BingoBoard instance."""
        self.size = size
        self.number_pool = list(range(1, number_pool_size + 1))
        # Ensure enough numbers are available for the board
        if size**2 > len(self.number_pool):
            raise ValueError(
                f"Not enough numbers in the pool ({number_pool_size}) "
                f"for a {size}x{size} board ({size**2} numbers needed)."
            )
        self.matrix = self.create_board_matrix(self.size)

    def create_board_matrix(self, size) -> dict:
        """Creates a square matrix for the Bingo board with unique random numbers."""
        array_1d = np.array(random.sample(self.number_pool, size**2))
        array_2d = array_1d.reshape((size, size))
        output_board = {}
        for r_idx in range(size):
            row_dict = {}
            for c_idx in range(size):
                row_dict[c_idx] = int(array_2d[r_idx, c_idx])
            output_board[r_idx] = row_dict
        return output_board

    def to_dataframe(self) -> pd.DataFrame:
        """
        Converts the board matrix to a pandas DataFrame for easy viewing.

        Returns:
            pd.DataFrame: A DataFrame representation of the Bingo board.
        """
        df = pd.DataFrame(self.matrix).T
        self.df = df
        return df

    def print_board(self) -> str:
        """
        Prints the Bingo board to the logger and returns its string representation.

        Returns:
            str: The string representation of the board DataFrame.
        """
        df = self.to_dataframe()
        lg.info(f"generated board:\n{df}")
        return df.to_string()

    def to_json(self, df: Optional[pd.DataFrame] = None) -> str:
        if df is None:
            df = self.to_dataframe()
        return df.to_json(orient="index")


class BingoGame:
    """
    Manages a Bingo game, including generating boards and determining winners.
    """

    winning_numbers: list[int] = []

    def __init__(self, size=7, number_pool_size: int = 200):
        """
        Initializes a BingoGame instance.

        Args:
            size (int): The default size for boards generated by this game.
            number_pool_size (int): The size of the number pool for the game.
        """
        self.size = size
        self.number_pool_size = number_pool_size

    def generate_board(self) -> BingoBoard:
        """
        Generates a new Bingo board for the game.

        Returns:
            BingoBoard: A new BingoBoard instance.
        """
        return BingoBoard(size=self.size, number_pool_size=self.number_pool_size)

    def generate_winning_numbers(self, count: int = 50) -> list[int]:
        """
        Generates a list of winning numbers by sampling from the game's number pool.

        Args:
            count (int): The number of winning numbers to generate.

        Returns:
            list[int]: A list of randomly selected winning numbers.
        """
        if count > self.number_pool_size:
            raise ValueError(
                f"Cannot generate {count} winning numbers from a pool of size "
                f"{self.number_pool_size}. Count must be less than or equal to pool size."
            )
        self.winning_numbers = random.sample(range(1, self.number_pool_size + 1), count)
        return self.winning_numbers

    def validate_board(
        self, board: BingoBoard, print_marked_board: bool = False
    ) -> BingoBoard:
        """
        Validates if the given BingoBoard has a winning line (row, column, or diagonal)
        based on the game's winning numbers, using pandas functions.

        Args:
            board (BingoBoard): The BingoBoard instance to validate.

        Returns:
            bool: True if the board has a winning line, False otherwise.
        """
        if not self.winning_numbers:
            lg.warning(
                "No winning numbers have been generated yet. Board cannot be validated."
            )
            board.is_winner = False
            return board

        # Convert winning numbers to a set for efficient lookups
        winning_set = set(self.winning_numbers)

        # Convert the board matrix to a pandas DataFrame
        df_board = board.to_dataframe()

        # Create a boolean DataFrame where True indicates a number is in winning_set
        df_marked = df_board.isin(winning_set)
        board.df_marked = df_marked  # Store marked DataFrame in the board instance
        board.json_str_marked = board.to_json(df_marked)  # Store marked data as json
        if print_marked_board:
            dfm = df_marked.replace({False: " ", True: "W"})
            lg.info(f"Marked board:\n{dfm}")

        # Check rows: if any row is all True
        if df_marked.all(axis=1).any():
            winning_row_idx = df_marked.all(axis=1).idxmax()
            lg.debug(f"Winning row found: {df_board.loc[winning_row_idx].tolist()}")
            board.is_winner = True
            return board

        # Check columns: if any column is all True
        if df_marked.all(axis=0).any():
            winning_col_idx = df_marked.all(axis=0).idxmax()
            lg.debug(f"Winning column found: {df_board[winning_col_idx].tolist()}")
            board.is_winner = True
            return board

        # Check main diagonal (top-left to bottom-right)
        # Extract the main diagonal as a pandas Series and check if all are True
        main_diag_marked = pd.Series([df_marked.iloc[i, i] for i in range(board.size)])
        if main_diag_marked.all():
            main_diag_numbers = [int(df_board.iloc[i, i]) for i in range(board.size)]
            lg.debug(f"Winning main diagonal found: {main_diag_numbers}")
            board.is_winner = True
            return board

        # Check anti-diagonal (top-right to bottom-left)
        # Extract the anti-diagonal as a pandas Series and check if all are True
        anti_diag_marked = pd.Series(
            [df_marked.iloc[i, board.size - 1 - i] for i in range(board.size)]
        )
        if anti_diag_marked.all():
            anti_diag_numbers = [
                int(df_board.iloc[i, board.size - 1 - i]) for i in range(board.size)
            ]
            lg.debug(f"Winning anti-diagonal found: {anti_diag_numbers}")
            board.is_winner = True
            return board

        # If no winning line is found
        lg.debug("No winning line found on the board.")
        board.is_winner = False
        return board

    def count_winning_boards(self, boards: list[BingoBoard]) -> int:
        """Counts the number of winning boards in a list of BingoBoard instances."""
        return sum(1 for board in boards if self.validate_board(board).is_winner)


def demo_gauranteed_win():
    """
    Demonstrates a guaranteed win scenario by creating a Bingo board
    where the first row is guaranteed to be a winning line.
    """
    lg.info("Demonstrating a guaranteed win scenario.")
    guaranteed_win_game = BingoGame(size=3, number_pool_size=10)
    guaranteed_board = guaranteed_win_game.generate_board()
    guaranteed_board.print_board()

    # Ensure the first row is in winning numbers
    first_row_numbers = [
        guaranteed_board.matrix[0][c] for c in range(guaranteed_board.size)
    ]
    # Add first row numbers and some random numbers to ensure enough winning numbers
    guaranteed_win_game.winning_numbers = list(
        set(first_row_numbers + random.sample(range(1, 10), 3))
    )
    lg.info(f"Guaranteed winning numbers: {guaranteed_win_game.winning_numbers}")

    # Validate the board against the winning numbers
    is_guaranteed_winner = guaranteed_win_game.validate_board(guaranteed_board)
    lg.info(f"Is the guaranteed board a winner? {is_guaranteed_winner}")
